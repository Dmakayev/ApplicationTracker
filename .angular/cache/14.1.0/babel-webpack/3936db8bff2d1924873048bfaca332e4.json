{"ast":null,"code":"import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\n\nfunction fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n\n\n  return new Observable(function (subscriber) {\n    var unsubscribe = onSnapshot(ref, options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nfunction doc(ref) {\n  return fromRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\n\n\nfunction docData(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, options);\n  }));\n}\n\nfunction snapToData(snapshot, options) {\n  if (options === void 0) {\n    options = {};\n  } // TODO clean up the typings\n\n\n  var data = snapshot.data(); // match the behavior of the JS SDK when the snapshot doesn't exist\n  // it's possible with data converters too that the user didn't return an object\n\n  if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n    return data;\n  }\n\n  if (options.idField) {\n    data[options.idField] = snapshot.id;\n  }\n\n  return data;\n}\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\n\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\n\n\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\n\n\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\n\n\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\n\n\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\n\n\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n        current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\n\n\nfunction collectionChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n        currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return refEqual(c.doc.ref, currentDocSnapshot.ref);\n        });\n\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return refEqual(d.ref, currentDocSnapshot.ref);\n          });\n\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n\n    return docChanges;\n  }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction collection(query) {\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\n\n\nfunction sortedChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, options.events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\n\n\nfunction auditTrail(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collectionChanges(query, options).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\n\n\nfunction collectionData(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, options);\n    });\n  }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };","map":{"version":3,"names":["__spreadArray","onSnapshot","refEqual","Observable","pipe","map","startWith","pairwise","filter","scan","distinctUntilChanged","DEFAULT_OPTIONS","includeMetadataChanges","fromRef","ref","options","subscriber","unsubscribe","next","bind","error","complete","doc","docData","snap","snapToData","snapshot","data","exists","idField","id","ALL_EVENTS","filterEvents","events","changes","hasChange","i","length","change","indexOf","type","sliceAndSplice","original","start","deleteCount","args","_i","arguments","returnArray","slice","splice","apply","processIndividualChange","combined","newIndex","oldIndex","copiedArray","processDocumentChanges","current","forEach","windowwise","undefined","metaDataEquals","a","b","JSON","stringify","metadata","filterEmptyUnlessFirst","_a","prior","collectionChanges","query","priorSnapshot","currentSnapshot","docChanges","docs","currentDocSnapshot","currentIndex","currentDocChange","find","c","priorDocSnapshot","d","push","collection","sortedChanges","auditTrail","action","collectionData","arr"],"sources":["/Users/dmakayev/WebstormProjects/ApplicationTracker/node_modules/rxfire/firestore/index.esm.js"],"sourcesContent":["import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\nfunction fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = onSnapshot(ref, options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction doc(ref) {\n    return fromRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nfunction docData(ref, options) {\n    if (options === void 0) { options = {}; }\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, options); }));\n}\nfunction snapToData(snapshot, options) {\n    if (options === void 0) { options = {}; }\n    // TODO clean up the typings\n    var data = snapshot.data();\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    // it's possible with data converters too that the user didn't return an object\n    if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n        return data;\n    }\n    if (options.idField) {\n        data[options.idField] = snapshot.id;\n    }\n    return data;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        _a[0]; var current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nfunction collectionChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return fromRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return refEqual(c.doc.ref, currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return refEqual(d.ref, currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nfunction collection(query) {\n    return fromRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nfunction sortedChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, options.events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nfunction auditTrail(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nfunction collectionData(query, options) {\n    if (options === void 0) { options = {}; }\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, options); });\n    }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };\n"],"mappings":"AAAA,SAASA,aAAT,QAA8B,OAA9B;AACA,SAASC,UAAT,EAAqBC,QAArB,QAAqC,oBAArC;AACA,SAASC,UAAT,EAAqBC,IAArB,QAAiC,MAAjC;AACA,SAASC,GAAT,EAAcC,SAAd,EAAyBC,QAAzB,EAAmCC,MAAnC,EAA2CC,IAA3C,EAAiDC,oBAAjD,QAA6E,gBAA7E;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,eAAe,GAAG;EAAEC,sBAAsB,EAAE;AAA1B,CAAtB;;AACA,SAASC,OAAT,CAAiBC,GAAjB,EAAsBC,OAAtB,EAA+B;EAC3B,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAGJ,eAAV;EAA4B;EACtD;;;EACA,OAAO,IAAIR,UAAJ,CAAe,UAAUa,UAAV,EAAsB;IACxC,IAAIC,WAAW,GAAGhB,UAAU,CAACa,GAAD,EAAMC,OAAN,EAAe;MACvCG,IAAI,EAAEF,UAAU,CAACE,IAAX,CAAgBC,IAAhB,CAAqBH,UAArB,CADiC;MAEvCI,KAAK,EAAEJ,UAAU,CAACI,KAAX,CAAiBD,IAAjB,CAAsBH,UAAtB,CAFgC;MAGvCK,QAAQ,EAAEL,UAAU,CAACK,QAAX,CAAoBF,IAApB,CAAyBH,UAAzB;IAH6B,CAAf,CAA5B;IAKA,OAAO;MAAEC,WAAW,EAAEA;IAAf,CAAP;EACH,CAPM,CAAP;AAQH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,GAAT,CAAaR,GAAb,EAAkB;EACd,OAAOD,OAAO,CAACC,GAAD,EAAM;IAAEF,sBAAsB,EAAE;EAA1B,CAAN,CAAd;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASW,OAAT,CAAiBT,GAAjB,EAAsBC,OAAtB,EAA+B;EAC3B,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,OAAOO,GAAG,CAACR,GAAD,CAAH,CAASV,IAAT,CAAcC,GAAG,CAAC,UAAUmB,IAAV,EAAgB;IAAE,OAAOC,UAAU,CAACD,IAAD,EAAOT,OAAP,CAAjB;EAAmC,CAAtD,CAAjB,CAAP;AACH;;AACD,SAASU,UAAT,CAAoBC,QAApB,EAA8BX,OAA9B,EAAuC;EACnC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe,CADN,CAEnC;;;EACA,IAAIY,IAAI,GAAGD,QAAQ,CAACC,IAAT,EAAX,CAHmC,CAInC;EACA;;EACA,IAAI,CAACD,QAAQ,CAACE,MAAT,EAAD,IAAsB,OAAOD,IAAP,KAAgB,QAAtC,IAAkDA,IAAI,KAAK,IAA/D,EAAqE;IACjE,OAAOA,IAAP;EACH;;EACD,IAAIZ,OAAO,CAACc,OAAZ,EAAqB;IACjBF,IAAI,CAACZ,OAAO,CAACc,OAAT,CAAJ,GAAwBH,QAAQ,CAACI,EAAjC;EACH;;EACD,OAAOH,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAII,UAAU,GAAG,CAAC,OAAD,EAAU,UAAV,EAAsB,SAAtB,CAAjB;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,YAAY,GAAG,UAAUC,MAAV,EAAkB;EACjC,OAAOzB,MAAM,CAAC,UAAU0B,OAAV,EAAmB;IAC7B,IAAIC,SAAS,GAAG,KAAhB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACG,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;MACrC,IAAIE,MAAM,GAAGJ,OAAO,CAACE,CAAD,CAApB;;MACA,IAAIH,MAAM,IAAIA,MAAM,CAACM,OAAP,CAAeD,MAAM,CAACE,IAAtB,KAA+B,CAA7C,EAAgD;QAC5CL,SAAS,GAAG,IAAZ;QACA;MACH;IACJ;;IACD,OAAOA,SAAP;EACH,CAVY,CAAb;AAWH,CAZD;AAaA;AACA;AACA;AACA;;;AACA,SAASM,cAAT,CAAwBC,QAAxB,EAAkCC,KAAlC,EAAyCC,WAAzC,EAAsD;EAClD,IAAIC,IAAI,GAAG,EAAX;;EACA,KAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACV,MAAhC,EAAwCS,EAAE,EAA1C,EAA8C;IAC1CD,IAAI,CAACC,EAAE,GAAG,CAAN,CAAJ,GAAeC,SAAS,CAACD,EAAD,CAAxB;EACH;;EACD,IAAIE,WAAW,GAAGN,QAAQ,CAACO,KAAT,EAAlB;EACAD,WAAW,CAACE,MAAZ,CAAmBC,KAAnB,CAAyBH,WAAzB,EAAsChD,aAAa,CAAC,CAAC2C,KAAD,EAAQC,WAAR,CAAD,EAAuBC,IAAvB,CAAnD;EACA,OAAOG,WAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASI,uBAAT,CAAiCC,QAAjC,EAA2Cf,MAA3C,EAAmD;EAC/C,QAAQA,MAAM,CAACE,IAAf;IACI,KAAK,OAAL;MACI,IAAIa,QAAQ,CAACf,MAAM,CAACgB,QAAR,CAAR,IACApD,QAAQ,CAACmD,QAAQ,CAACf,MAAM,CAACgB,QAAR,CAAR,CAA0BhC,GAA1B,CAA8BR,GAA/B,EAAoCwB,MAAM,CAAChB,GAAP,CAAWR,GAA/C,CADZ,EACiE,CADjE,KAEK;QACD,OAAO2B,cAAc,CAACY,QAAD,EAAWf,MAAM,CAACgB,QAAlB,EAA4B,CAA5B,EAA+BhB,MAA/B,CAArB;MACH;MACD;;IACJ,KAAK,UAAL;MACI,IAAIe,QAAQ,CAACf,MAAM,CAACiB,QAAR,CAAR,IAA6B,IAA7B,IACArD,QAAQ,CAACmD,QAAQ,CAACf,MAAM,CAACiB,QAAR,CAAR,CAA0BjC,GAA1B,CAA8BR,GAA/B,EAAoCwB,MAAM,CAAChB,GAAP,CAAWR,GAA/C,CADZ,EACiE;QAC7D;QACA;QACA,IAAIwB,MAAM,CAACiB,QAAP,KAAoBjB,MAAM,CAACgB,QAA/B,EAAyC;UACrC,IAAIE,WAAW,GAAGH,QAAQ,CAACJ,KAAT,EAAlB;UACAO,WAAW,CAACN,MAAZ,CAAmBZ,MAAM,CAACiB,QAA1B,EAAoC,CAApC;UACAC,WAAW,CAACN,MAAZ,CAAmBZ,MAAM,CAACgB,QAA1B,EAAoC,CAApC,EAAuChB,MAAvC;UACA,OAAOkB,WAAP;QACH,CALD,MAMK;UACD,OAAOf,cAAc,CAACY,QAAD,EAAWf,MAAM,CAACgB,QAAlB,EAA4B,CAA5B,EAA+BhB,MAA/B,CAArB;QACH;MACJ;;MACD;;IACJ,KAAK,SAAL;MACI,IAAIe,QAAQ,CAACf,MAAM,CAACiB,QAAR,CAAR,IACArD,QAAQ,CAACmD,QAAQ,CAACf,MAAM,CAACiB,QAAR,CAAR,CAA0BjC,GAA1B,CAA8BR,GAA/B,EAAoCwB,MAAM,CAAChB,GAAP,CAAWR,GAA/C,CADZ,EACiE;QAC7D,OAAO2B,cAAc,CAACY,QAAD,EAAWf,MAAM,CAACiB,QAAlB,EAA4B,CAA5B,CAArB;MACH;;MACD;EA7BR;;EA+BA,OAAOF,QAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,sBAAT,CAAgCC,OAAhC,EAAyCxB,OAAzC,EAAkDD,MAAlD,EAA0D;EACtD,IAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;IAAEA,MAAM,GAAGF,UAAT;EAAsB;;EAC/CG,OAAO,CAACyB,OAAR,CAAgB,UAAUrB,MAAV,EAAkB;IAC9B;IACA,IAAIL,MAAM,CAACM,OAAP,CAAeD,MAAM,CAACE,IAAtB,IAA8B,CAAC,CAAnC,EAAsC;MAClCkB,OAAO,GAAGN,uBAAuB,CAACM,OAAD,EAAUpB,MAAV,CAAjC;IACH;EACJ,CALD;EAMA,OAAOoB,OAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,IAAIE,UAAU,GAAG,YAAY;EACzB,OAAOxD,IAAI,CAACE,SAAS,CAACuD,SAAD,CAAV,EAAuBtD,QAAQ,EAA/B,CAAX;AACH,CAFD;AAGA;AACA;AACA;AACA;AACA;;;AACA,IAAIuD,cAAc,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;EAAE,OAAOC,IAAI,CAACC,SAAL,CAAeH,CAAC,CAACI,QAAjB,MAA+BF,IAAI,CAACC,SAAL,CAAeF,CAAC,CAACG,QAAjB,CAAtC;AAAmE,CAA1G;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,sBAAsB,GAAG,YAAY;EACrC,OAAOhE,IAAI,CAACwD,UAAU,EAAX,EAAepD,MAAM,CAAC,UAAU6D,EAAV,EAAc;IAC3C,IAAIC,KAAK,GAAGD,EAAE,CAAC,CAAD,CAAd;IAAA,IAAmBX,OAAO,GAAGW,EAAE,CAAC,CAAD,CAA/B;IACA,OAAOX,OAAO,CAACrB,MAAR,GAAiB,CAAjB,IAAsBiC,KAAK,KAAKT,SAAvC;EACH,CAH+B,CAArB,EAGPxD,GAAG,CAAC,UAAUgE,EAAV,EAAc;IAClBA,EAAE,CAAC,CAAD,CAAF;IAAO,IAAIX,OAAO,GAAGW,EAAE,CAAC,CAAD,CAAhB;IACP,OAAOX,OAAP;EACH,CAHM,CAHI,CAAX;AAOH,CARD;AASA;AACA;AACA;AACA;AACA;;;AACA,SAASa,iBAAT,CAA2BC,KAA3B,EAAkCzD,OAAlC,EAA2C;EACvC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,OAAOF,OAAO,CAAC2D,KAAD,EAAQ;IAAE5D,sBAAsB,EAAE;EAA1B,CAAR,CAAP,CAAiDR,IAAjD,CAAsDwD,UAAU,EAAhE,EAAoEvD,GAAG,CAAC,UAAUgE,EAAV,EAAc;IACzF,IAAII,aAAa,GAAGJ,EAAE,CAAC,CAAD,CAAtB;IAAA,IAA2BK,eAAe,GAAGL,EAAE,CAAC,CAAD,CAA/C;IACA,IAAIM,UAAU,GAAGD,eAAe,CAACC,UAAhB,EAAjB;;IACA,IAAIF,aAAa,IAAI,CAACX,cAAc,CAACW,aAAD,EAAgBC,eAAhB,CAApC,EAAsE;MAClE;MACA;MACA;MACAA,eAAe,CAACE,IAAhB,CAAqBjB,OAArB,CAA6B,UAAUkB,kBAAV,EAA8BC,YAA9B,EAA4C;QACrE,IAAIC,gBAAgB,GAAGJ,UAAU,CAACK,IAAX,CAAgB,UAAUC,CAAV,EAAa;UAChD,OAAO/E,QAAQ,CAAC+E,CAAC,CAAC3D,GAAF,CAAMR,GAAP,EAAY+D,kBAAkB,CAAC/D,GAA/B,CAAf;QACH,CAFsB,CAAvB;;QAGA,IAAIiE,gBAAJ,EAAsB;UAClB;UACA,IAAIjB,cAAc,CAACiB,gBAAgB,CAACzD,GAAlB,EAAuBuD,kBAAvB,CAAlB,EAA8D;YAC1D;UACH;QACJ,CALD,MAMK;UACD;UACA,IAAIK,gBAAgB,GAAGT,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GAAqD,KAAK,CAA1D,GAA8DA,aAAa,CAACG,IAAd,CAAmBI,IAAnB,CAAwB,UAAUG,CAAV,EAAa;YACtH,OAAOjF,QAAQ,CAACiF,CAAC,CAACrE,GAAH,EAAQ+D,kBAAkB,CAAC/D,GAA3B,CAAf;UACH,CAFoF,CAArF;;UAGA,IAAIoE,gBAAgB,IAChBpB,cAAc,CAACoB,gBAAD,EAAmBL,kBAAnB,CADlB,EAC0D;YACtD;UACH;QACJ;;QACDF,UAAU,CAACS,IAAX,CAAgB;UACZ7B,QAAQ,EAAEuB,YADE;UAEZxB,QAAQ,EAAEwB,YAFE;UAGZtC,IAAI,EAAE,UAHM;UAIZlB,GAAG,EAAEuD;QAJO,CAAhB;MAMH,CA1BD;IA2BH;;IACD,OAAOF,UAAP;EACH,CApC6E,CAAvE,EAoCH3C,YAAY,CAACjB,OAAO,CAACkB,MAAR,IAAkBF,UAAnB,CApCT,EAoCyCqC,sBAAsB,EApC/D,CAAP;AAqCH;AACD;AACA;AACA;AACA;;;AACA,SAASiB,UAAT,CAAoBb,KAApB,EAA2B;EACvB,OAAO3D,OAAO,CAAC2D,KAAD,EAAQ;IAAE5D,sBAAsB,EAAE;EAA1B,CAAR,CAAP,CAAiDR,IAAjD,CAAsDC,GAAG,CAAC,UAAU6B,OAAV,EAAmB;IAAE,OAAOA,OAAO,CAAC0C,IAAf;EAAsB,CAA5C,CAAzD,CAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASU,aAAT,CAAuBd,KAAvB,EAA8BzD,OAA9B,EAAuC;EACnC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,OAAOwD,iBAAiB,CAACC,KAAD,EAAQzD,OAAR,CAAjB,CAAkCX,IAAlC,CAAuCK,IAAI,CAAC,UAAUiD,OAAV,EAAmBxB,OAAnB,EAA4B;IAC3E,OAAOuB,sBAAsB,CAACC,OAAD,EAAUxB,OAAV,EAAmBnB,OAAO,CAACkB,MAA3B,CAA7B;EACH,CAFiD,EAE/C,EAF+C,CAA3C,EAECvB,oBAAoB,EAFrB,CAAP;AAGH;AACD;AACA;AACA;AACA;;;AACA,SAAS6E,UAAT,CAAoBf,KAApB,EAA2BzD,OAA3B,EAAoC;EAChC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,OAAOwD,iBAAiB,CAACC,KAAD,EAAQzD,OAAR,CAAjB,CAAkCX,IAAlC,CAAuCK,IAAI,CAAC,UAAUiD,OAAV,EAAmB8B,MAAnB,EAA2B;IAAE,OAAOxF,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK0D,OAAL,CAAd,EAA6B8B,MAA7B,CAApB;EAA2D,CAAzF,EAA2F,EAA3F,CAA3C,CAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBjB,KAAxB,EAA+BzD,OAA/B,EAAwC;EACpC,IAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;IAAEA,OAAO,GAAG,EAAV;EAAe;;EACzC,OAAOsE,UAAU,CAACb,KAAD,CAAV,CAAkBpE,IAAlB,CAAuBC,GAAG,CAAC,UAAUqF,GAAV,EAAe;IAC7C,OAAOA,GAAG,CAACrF,GAAJ,CAAQ,UAAUmB,IAAV,EAAgB;MAAE,OAAOC,UAAU,CAACD,IAAD,EAAOT,OAAP,CAAjB;IAAmC,CAA7D,CAAP;EACH,CAFgC,CAA1B,CAAP;AAGH;;AAED,SAASwE,UAAT,EAAqBF,UAArB,EAAiCd,iBAAjC,EAAoDkB,cAApD,EAAoEnE,GAApE,EAAyEC,OAAzE,EAAkFV,OAAlF,EAA2FY,UAA3F,EAAuG6D,aAAvG"},"metadata":{},"sourceType":"module"}